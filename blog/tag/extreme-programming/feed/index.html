<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>extreme programming &#8211; antonymarcano.com</title>
	<atom:link href="/blog/tag/extreme-programming/feed/" rel="self" type="application/rss+xml" />
	<link>/blog</link>
	<description>Thinking through writing... on innovation, business, technology and more</description>
	<lastBuildDate>Sat, 03 Sep 2016 10:48:44 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.8.14</generator>
	<item>
		<title>Scenario-Oriented vs. Rules-Oriented Acceptance Criteria</title>
		<link>/blog/2011/10/scenario-oriented-vs-rules-oriented-acceptance-criteria/</link>
		<comments>/blog/2011/10/scenario-oriented-vs-rules-oriented-acceptance-criteria/#comments</comments>
		<pubDate>Sun, 02 Oct 2011 13:59:19 +0000</pubDate>
		<dc:creator><![CDATA[AntonyMarcano]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[BDD/ATDD]]></category>
		<category><![CDATA[Business Analysis]]></category>
		<category><![CDATA[Software Development]]></category>
		<category><![CDATA[Software Testing]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[Acceptance testing]]></category>
		<category><![CDATA[agile]]></category>
		<category><![CDATA[ATDD]]></category>
		<category><![CDATA[BDD]]></category>
		<category><![CDATA[extreme programming]]></category>
		<category><![CDATA[Software testing]]></category>
		<category><![CDATA[TDD]]></category>

		<guid isPermaLink="false">/blog/?p=393</guid>
		<description><![CDATA[Acceptance Criteria, Scenarios, Acceptance Tests are, in my experience, often a source of confusion. Such confusion results in questions like the one asked of Rachel Davies recently, i.e. &#8220;When to write story tests&#8221; (sometimes also known as &#8220;Acceptance Tests&#8221; or in BDD parlance &#8220;Scenarios&#8221;). In her answer, Rachel highlighted that: &#8220;&#8230;acceptance criteria and example scenarios &#8230; <a href="/blog/2011/10/scenario-oriented-vs-rules-oriented-acceptance-criteria/" class="more-link">Continue reading <span class="screen-reader-text">Scenario-Oriented vs. Rules-Oriented Acceptance Criteria</span> <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Acceptance Criteria, Scenarios, Acceptance Tests are, in my experience, often a source of confusion.</p>
<p>Such confusion results in questions like the one <a href="http://agilecoach.typepad.com/agile-coaching/2011/07/when-to-write-story-tests.html ">asked of Rachel Davies recently</a>, i.e. &#8220;When to write story tests&#8221; (sometimes also known as &#8220;Acceptance Tests&#8221; or in BDD parlance &#8220;Scenarios&#8221;).</p>
<p>In her answer, Rachel highlighted that:</p>
<blockquote><p><em>&#8220;</em><em>&#8230;acceptance criteria and example scenarios are a bit like the chicken and the egg &#8211; it&#8217;s not always clear which comes first so iterate!&#8221;</em></p></blockquote>
<p>In that article, Rachel distinguishes between acceptance criteria and example scenarios by reference to <a href="http://lizkeogh.com/2011/06/20/acceptance-criteria-vs-scenarios/">Liz Keogh&#8217;s blog post on the subject of &#8220;Acceptance Criteria vs. Scenarios&#8221;</a>:</p>
<blockquote><p><em>&#8220;</em><em>where she explains that acceptance criteria are general rules covering system behaviour from which executable examples (Scenarios) can be derived</em>&#8220;</p></blockquote>
<p>Seeing the acceptance criteria as rules and the scenarios as something else, is one way of looking at it. There&#8217;s another way too&#8230;</p>
<p>Instead of Acceptance Criteria that are rules and Acceptance Tests that are scenarios&#8230; I often find it useful to arrive at Acceptance Criteria that are scenarios, of which the Acceptance Tests are just a more detailed expression.</p>
<p>I.e. Scenario-Oriented Acceptance Criteria.</p>
<h3>Expressing the Intent of the Story</h3>
<p>Many teams I encounter, especially newer ones, place higher importance on the things we label &#8220;acceptance criteria&#8221; than on the things we label &#8220;acceptance tests&#8221; or &#8220;scenarios&#8221;.</p>
<p>By this I mean that, such a team might ultimately determine whether the intent of the story was fulfilled by evaluating the product against these rules-oriented criteria. Worse still, I&#8217;ve observed some teams also have:</p>
<ul>
<li>Overheads of checking that these rule-based criteria are fulfilled as well as the scenario-oriented acceptance tests</li>
<li>Teams working in silos where BAs take sole responsibility of criteria and testers take sole responsibility for scenarios</li>
<li>A desire to have traceability from the acceptance tests back to the acceptance criteria</li>
<li>Rules expressed as rules in two places &#8211; the criteria and the code</li>
<li>Criteria treated as the specification, rather than using specification by example</li>
</ul>
<p>If we take the approach of not distinguishing between acceptance criteria and acceptance tests (i.e. see the acceptance tests as the acceptance criteria) then we can encourage teams away from these kinds of problems.</p>
<p>I&#8217;m not saying it solves the problem &#8211; it&#8217;s just easier, in my experience, to move the team towards collaboratively arriving at a shared understanding of the intent of the story this way.</p>
<p>To do this, we need to iteratively evolve our acceptance criteria from rules-oriented to scenario-oriented criteria.</p>
<h3>Acceptance Criteria: from rules-oriented to scenario-oriented:</h3>
<p>Let&#8217;s say we had this user story:</p>
<pre>As a snapshot photographer</pre>
<pre>I want some photo albums to be private</pre>
<pre>So that I have a backup of my personal photos online</pre>
<p>And let&#8217;s say the product owner first expresses the Acceptance Criteria as rules:</p>
<ul>
<li>Must have a way to set the privacy of photo albums</li>
<li>Private albums must be visible to me</li>
<li>Private albums must not be visible to others</li>
</ul>
<p>We might discuss those to identify scenarios (as vertical slices through the above criteria):</p>
<ul>
<li>Create new private album</li>
<li>Make public album private</li>
<li>Make private album public</li>
</ul>
<p>Here, many teams would retain both acceptance criteria and scenarios. That&#8217;s ok but I&#8217;d only do that if we collectively understood that the information from these two will come together in the acceptance tests&#8230; And that whatever we agree in those acceptance tests supersede the previously discussed criteria.</p>
<p>This understanding tends to occur in highly collaborative teams. In newer teams, where disciplines (Business Analysts, Testers, Developers) are working more independently this tends to be harder to achieve.</p>
<p>In those situations (and often even in highly collaborative teams) I&#8217;d continue the discussion to iterate over the rules-oriented criteria to arrive at scenario-oriented criteria, carrying over any information captured in the rules, discarding the original rules-based criteria as we go. This might leave me with the following scenarios:</p>
<ul>
<li>Create new private album (visible to me, not to others)</li>
<li>Make public album private (visible to me, not to others)</li>
<li>Make private album public (visible to me, &amp; others)</li>
</ul>
<p>Which, with a subtle change to the wording, become the acceptance criteria. I.e. the story is complete when we:</p>
<ul>
<li>Can create new private album (visible to me, not to others)</li>
<li>Can make public album private (visible to me, not to others)</li>
<li>Can make private album public (visible to me, &amp; others)</li>
</ul>
<p>Once the story is &#8216;in-play&#8217; (e.g. during a time-box/iteration/sprint) I&#8217;d elaborate these one at a time, implementing just enough to get each one passing as I go. By doing this we might arrive at:</p>
<pre>Scenario: Can Create new private album
When I create a new private album called "Weekend in Brighton"
Then I should be able to see the album
And others should not be able to see it

Scenario: Can Make public album private
Given there is a public album called "Friday Night"
When I make that album private
Then I should be able to see the album
And others should not be able to see it

Scenario: Can Make private album public
Given there is a private album called "Friday Night"
When I make that album public
Then I should be able to see the album
And others should be able to see it</pre>
<p>By being an elaboration of the scenario-oriented acceptance criteria there&#8217;s no implied need to also check the implementation against the original &#8216;rules-oriented&#8217; criteria.</p>
<p>Agreeing that this is how we&#8217;ll work, it encourages more collaborative working &#8211; at least between the Business Analysts and Testers.</p>
<p>These new scenario-based criteria become the only means of determining whether the intent of the story has been fulfilled, avoiding much of the confusion that can occur when we have rules-oriented acceptance criteria as well as separate acceptance test scenarios.</p>
<p>In short, more often than not, I find these things much easier when the criteria and the scenarios are essentially one and the same.</p>
<p>Why not  give it a try?</p>
]]></content:encoded>
			<wfw:commentRss>/blog/2011/10/scenario-oriented-vs-rules-oriented-acceptance-criteria/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
		<item>
		<title>Old Favourite: Expected Exceptions</title>
		<link>/blog/2010/07/old-favourite-expected-exceptions/</link>
		<comments>/blog/2010/07/old-favourite-expected-exceptions/#comments</comments>
		<pubDate>Sat, 24 Jul 2010 21:03:48 +0000</pubDate>
		<dc:creator><![CDATA[AntonyMarcano]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Software Development]]></category>
		<category><![CDATA[Software Testing]]></category>
		<category><![CDATA[Exception handling]]></category>
		<category><![CDATA[Exception handling syntax]]></category>
		<category><![CDATA[extreme programming]]></category>
		<category><![CDATA[Java]]></category>
		<category><![CDATA[junit]]></category>
		<category><![CDATA[old favourites]]></category>
		<category><![CDATA[programming]]></category>
		<category><![CDATA[TDD]]></category>

		<guid isPermaLink="false">/blog/?p=76</guid>
		<description><![CDATA[This first appeared on my old blog in November 2008. I&#8217;ve decided that I don&#8217;t like typical patterns for testing exceptions. I decided this a while ago as far as &#8220;Expected Exception&#8221; attributes/annotations are concerned and stuck with the traditional try/catch approach (I&#8217;ll explain why in a minute). Now, I&#8217;ve decided I don&#8217;t like the &#8230; <a href="/blog/2010/07/old-favourite-expected-exceptions/" class="more-link">Continue reading <span class="screen-reader-text">Old Favourite: Expected Exceptions</span> <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p><em>This first appeared on <a href="http://www.testingreflections.com/node/view/7585">my old blog in November 2008</a>.</em></p>
<p><img class="alignleft" src="http://farm4.static.flickr.com/3557/3583874642_a3751d874c_m.jpg" alt="" width="240" height="159" /></p>
<p>I&#8217;ve decided that I don&#8217;t like typical patterns for testing exceptions. I decided this a while ago as far as &#8220;Expected Exception&#8221; attributes/annotations are concerned and stuck with the traditional try/catch approach (I&#8217;ll explain why in a minute). Now, I&#8217;ve decided I don&#8217;t like the typical &#8220;try/fail or catch&#8221; approach and have started using a subtle evolution of it.</p>
<p>First, let me explain why I don&#8217;t like Expected Exception attributes/annotations. The final nail in the coffin of this approach was hammered home for me when working with <a href="http://lizkeogh.com/">Liz Keogh</a> a while back.</p>
<p>Here is an example in Java of your expected exception pattern (for brevity I won&#8217;t include assertions for e.getMessage()):</p>
<p><code> </code></p>
<p>&nbsp;</p>
<p><code></p>
<pre>@Test(expected=BeyondMyExpertiseException.class)
public void shouldComplainWhenNotAClass() throws Exception {
	DomainExpert expert = new DomainExpert();
	String thisCheckpoint = nameOfSomeInterface();

	expert.howDoIRestore(thisCheckpoint);
}</pre>
<p></code></p>
<p>&nbsp;</p>
<p>So, apart from the obvious fact that it is only implicit as to which method threw that exception (because I know that none of the other steps can throw that exception)&#8230; and we want our tests to communicate information explicitly, yes? The insight that Liz shared with me is that it changes the flow of information (ok, I&#8217;m paraphrasing now) compared to a test that doesn&#8217;t expect an exception.</p>
<p>In a &#8216;positive&#8217; test, the flow of information that is expressed to the reader is <em>What I need-&gt;what I do-&gt;what I expect</em>. In an expected exception test, this is changed to <em>what I expect-&gt;what I need-&gt;what I do</em>. The latter just doesn&#8217;t flow very well and because it&#8217;s different to your positive tests there&#8217;s an overhead involved for the reader (me or someone else later on) to process this shift in structure&#8230; I&#8217;ve found that such tests just don&#8217;t jump out at me when I&#8217;m scanning the tests&#8230;</p>
<p>Since then, despite fashion, I committed to the old-fashioned way of writing exceptions &#8211; &#8220;try/fail or catch&#8221;:</p>
<p>&nbsp;</p>
<p><code></p>
<pre>@Test
public void shouldComplainWhenNotAClass() throws Exception {
	DomainExpert expert = new DomainExpert();
	String thisCheckpoint = nameOfSomeInterface();

	try {
		expert.howDoIRestore(thisCheckpoint);
		fail("Should have thrown " +
			BeyondMyExpertiseException.class.getSimpleName());
	} catch (BeyondMyExpertiseException e) {
	}
}</pre>
<p></code></p>
<p>&nbsp;</p>
<p>Ok, I accept, it looks more cluttered by comparison but the flow of information makes more sense and I make it explicit that the expert.howDoIRestore(thisCheckpoint) method call is the one that should have thrown the exception. (Note: The idea here is not to reduce how much you type but to make the test more expressive). The &#8220;try/fail or catch approach only works when your code doesn&#8217;t throw an exception&#8230; If your code throws a different exception, the failure trace just tells you what exception was actually thrown, it doesn&#8217;t tell you what exception was expected. So, here is a slightly different way of writing it:</p>
<p>&nbsp;</p>
<p><code></p>
<pre>@Test
public void shouldComplainWhenNotAClass() throws Exception {
	DomainExpert expert = new DomainExpert();
	String thisCheckpoint = nameOfSomeInterface();
	try {
		expert.howDoIRestore(thisCheckpoint);
		fail();
	} catch (Exception e) {
		assertThat(e,is(instanceOf(
				BeyondMyExpertiseException.class)));
	}
}</pre>
<p></code></p>
<p>&nbsp;</p>
<p>Notice that I&#8217;m only catching <code>Exception</code> now, not <code>BeyondMyExpertiseException</code>. This still feels a little jumbled&#8230; Because my assertion is inside the catch block, I have to have the fail() method call just after the call that should throw the exception. Hmmm&#8230; don&#8217;t like that&#8230; Instead, this makes more sense:</p>
<p>&nbsp;</p>
<p><code></p>
<pre>@Test
public void shouldComplainWhenNotAClass() throws Exception {
	DomainExpert expert = new DomainExpert();
	String thisCheckpoint = nameOfSomeInterface();
	Exception thrownException = null;

	try {
		expert.howDoIRestore(thisCheckpoint);
	} catch (Exception e) {
		thrownException = e;
	}
	assertThat(thrownException,is(instanceOf(
				BeyondMyExpertiseException.class)));
}</pre>
<p></code></p>
<p>&nbsp;</p>
<p>Giving this failure trace when it fails:</p>
<p><code> </code></p>
<p>&nbsp;</p>
<p><code></p>
<pre>java.lang.AssertionError:
Expected: is an instance of
com.testingreflections.atdd.expertise.
    misunderstanding.BeyondMyExpertiseException
        got: &lt; java.lang.UnsupportedOperationException &gt;</pre>
<p></code></p>
<p>&nbsp;</p>
<p>So, for those who want to type as little as possible, this isn&#8217;t for you&#8230; But if you want tests that drive out your exception handling to be more expressive, then this is an alternative to the usual &#8220;try/fail or catch&#8221; approach. I think that perhaps there&#8217;s an even better way of doing this&#8230; maybe next I&#8217;ll see how approximating closures with an anonymous class might help improve the readability of this&#8230; Let me know if you know of a better way.</p>
]]></content:encoded>
			<wfw:commentRss>/blog/2010/07/old-favourite-expected-exceptions/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Taking repetition to task</title>
		<link>/blog/2010/07/taking-repetition-to-task/</link>
		<comments>/blog/2010/07/taking-repetition-to-task/#comments</comments>
		<pubDate>Thu, 08 Jul 2010 22:41:08 +0000</pubDate>
		<dc:creator><![CDATA[AntonyMarcano]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[BDD/ATDD]]></category>
		<category><![CDATA[Business Analysis]]></category>
		<category><![CDATA[Project Management]]></category>
		<category><![CDATA[agile]]></category>
		<category><![CDATA[ATDD]]></category>
		<category><![CDATA[BDD]]></category>
		<category><![CDATA[extreme programming]]></category>
		<category><![CDATA[old favourites]]></category>
		<category><![CDATA[TDD]]></category>
		<category><![CDATA[testing]]></category>
		<category><![CDATA[testingReflections]]></category>
		<category><![CDATA[user stories]]></category>

		<guid isPermaLink="false">/blog/?p=21</guid>
		<description><![CDATA[This originally appeared on my old blog in March 2010. Others have talked about the virtues of stories as vertical slices of a problem (end-to-end capabilities) rather than horizontal slices (system layers or components). So, if we slice the problem with user stories, how do we slice the user-stories themselves? If, as I sometimes say, &#8230; <a href="/blog/2010/07/taking-repetition-to-task/" class="more-link">Continue reading <span class="screen-reader-text">Taking repetition to task</span> <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p><em>This originally appeared </em><a href="http://www.testingreflections.com/node/view/8489"><em>on my old blog in March 2010</em></a><em>.</em></p>
<p>Others have talked about the virtues of <a href="http://blog.energizedwork.com/2005/05/slicing-cake.html">stories as vertical slices of a problem</a> (end-to-end capabilities) rather than horizontal slices (system layers or components). So, if we slice the problem <em>with</em> user stories, how do we slice the user-stories themselves?</p>
<p>If, as I sometimes say, acceptance tests (a.k.a. examples/scenarios/acceptance-criteria) are the knife with which we slice a story into even thinner vertical slices, then I would say my observation of &#8216;tasks&#8217; is that they are used as the knife used to cut a story into horizontal slices. This feels wrong&#8230;</p>
<p>Sometimes I also wonder, hasn&#8217;t anyone else noticed that the idea of counting the effort of completed tasks on burn-down/up charts is counter to the value that we measure progress only with working software? Surely it makes more sense to measure progress with passing tests (<a href="http://www.developsense.com/blog/2009/09/tests-vs-checks-should-we-call-test/">or &#8220;checks&#8221;</a> &#8211; whichever you prefer).</p>
<p>These are two of the reasons I&#8217;ve never felt very comfortable with tasks, because:</p>
<ul>
<li>they&#8217;re often applied in such a way that the story is sliced horizontally</li>
<li>they encourage measuring progress in a less meaningful way than working software</li>
</ul>
<p>Tasks are, however, very useful for teams at first. Just like anything else we learn how to do, learning how to do it on paper can often help us then discard the paper and do the workings in our heads. However, what I&#8217;ve noticed is that most teams I&#8217;ve worked with continue to write and estimate tasks long after the practice is useful or relevant to them.</p>
<p>For example, there comes a time for many teams where tasks become repetitive. &#8220;Add x to the Model&#8221;, &#8220;Change View&#8221;&#8230; and so on. Is this adding value to the process or are you just doing it because the process says you should do it?</p>
<p>Simply finding that your tasks are repetitive doesn&#8217;t mean the team is ready to stop using them. There is another important ingredient, meaningful acceptance criteria (scenarios / acceptance-tests / examples).</p>
<p>I often see stories with acceptance criteria such as:</p>
<ul>
<li>Must have a link to save the profile</li>
<li>Must have a drop down to select business sector</li>
<li>Business sector must be mandatory</li>
<li>&#8230;</li>
</ul>
<p>Although these are &#8220;acceptance criteria&#8221; they aren&#8217;t what we mean by acceptance criteria in the context of user stories. Firstly, they are talking about how the user interacts rather than what they need to achieve (I&#8217;ve <a href="http://www.testingreflections.com/node/view/6704">talked about this before</a>). Secondly, they aren&#8217;t examples. What we want are the variations that alter the behaviour or response of the product:</p>
<ul>
<li>Should create a new profile</li>
<li>Profile cannot be saved with blank &#8220;business sector&#8221;</li>
</ul>
<p>As our product fulfils each of these criteria, we are making progress. Jason Gorman <a href="http://parlezuml.com/blog/?postid=683">illustrates one way of approaching this</a>.</p>
<p>So, if you are using tasks, consider an alternative approach. First, look at your acceptance criteria, make sure they are more like examples and less like instructions. Once that&#8217;s achieved, consider slicing each criterion (or scenario) horizontally with the tasks rather than the story. Pretty soon, you&#8217;ll find that you don&#8217;t need tasks anymore and you can simply measure progress in terms of the new capabilities you add to your product.</p>
<p><em><strong>Updated 30-02-2010:</strong> I&#8217;ve inserted a new paragraph as the opening paragraph referencing an article on slicing user-stories to add some background to the vertical slicing metaphor. I&#8217;ve provided a link but I&#8217;m not sure who first came up with the metaphor.</em></p>
]]></content:encoded>
			<wfw:commentRss>/blog/2010/07/taking-repetition-to-task/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
	</channel>
</rss>
